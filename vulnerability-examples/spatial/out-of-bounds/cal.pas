(**
 * @file cal.pas
 * @brief Demonstration of an out-of-bounds write vulnerability in Pascal
 *
 * This program illustrates a buffer overflow vulnerability caused by missing bounds checking
 * in a record structure. It simulates a simple calendar display system where command-line
 * arguments can inadvertently corrupt critical variables such as the year.
 *
 * Vulnerability: The program defines a record `TSettings` containing an array and a year field.
 * The `SetFlag` procedure allows setting values inside the `flags` array without validating
 * the index, potentially allowing writes beyond the array into the `year` variable.
 *
 * @author Camilo Cunha de Azevedo <camilotk@gmail.com>
 * @date April 27, 2025
 *)

program Cal;

{$MODE OBJFPC}
{$RANGECHECKS OFF}  (* Intentionally disable range checking to allow exploitation *)

uses
  SysUtils, DateUtils;

type
  (**
   * @brief Packed settings structure
   *
   * Structure vulnerable to memory corruption. The `flags` array and the `year` field
   * are contiguous in memory, and overflow of `flags` can overwrite `year`.
   *)
  TSettings = packed record
    flags: array[0..3] of Integer; (* <-- Array of flags (vulnerable to overflow) *)
    year: Integer;                 (* <-- Year value, target for overflow *)
  end;

var
  Settings: TSettings;

(**
 * @brief Set a flag value by index (vulnerable)
 *
 * VULNERABILITY: This procedure allows writing to any index without validating bounds.
 * Supplying an index beyond 3 will overwrite adjacent memory fields, notably `year`.
 *
 * @param index The array index to set (no bounds checking)
 * @param value The value to assign
 *)
procedure SetFlag(index, value: Integer);
begin
  Settings.flags[index] := value; (* VULNERABILITY: No bounds checking *)
end;

(**
 * @brief Display the calendar header
 *
 * @param year The year to display
 *)
procedure DisplayHeader(year: Integer);
begin
  WriteLn;
  WriteLn('                              ', year);
  WriteLn('                           Calendar');
  WriteLn;
end;

(**
 * @brief Helper constants for month names
 *)
const
  MonthNames: array[1..12] of string = (
    'January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'
  );

(**
 * @brief Display three months side-by-side
 *
 * @param y Year
 * @param m1 First month
 * @param m2 Second month
 * @param m3 Third month
 *)
procedure DisplayThreeMonths(y, m1, m2, m3: Integer);
var
  d, w: Integer;
  cal: array[1..3, 0..5, 0..6] of Integer;
  firstDay: array[1..3] of Integer;
  daysCount: array[1..3] of Integer;
  i, month: Integer;
begin
  (* Calculate first day of the week and number of days for each month *)
  for month := 1 to 3 do
  begin
    firstDay[month] := DayOfTheWeek(EncodeDate(y, m1 + month - 1, 1)) mod 7;
    if firstDay[month] = 0 then
      firstDay[month] := 7;
    daysCount[month] := DaysInAMonth(y, m1 + month - 1);
    FillChar(cal[month], SizeOf(cal[month]), 0);
    d := 1;
    for w := 0 to 5 do
    begin
      for i := 0 to 6 do
      begin
        if (w = 0) and (i + 1 < firstDay[month]) then
          continue;
        if d > daysCount[month] then
          continue;
        cal[month][w][i] := d;
        Inc(d);
      end;
    end;
  end;

  (* Print month names *)
  WriteLn(Format('     %-12s         %-12s         %-12s', [MonthNames[m1], MonthNames[m2], MonthNames[m3]]));
  WriteLn('Su Mo Tu We Th Fr Sa    Su Mo Tu We Th Fr Sa    Su Mo Tu We Th Fr Sa');

  (* Print calendar weeks *)
  for w := 0 to 5 do
  begin
    for month := 1 to 3 do
    begin
      for i := 0 to 6 do
      begin
        if cal[month][w][i] = 0 then
          Write('   ')
        else
          Write(Format('%2d ', [cal[month][w][i]]));
      end;
      Write('   ');
    end;
    WriteLn;
  end;
  WriteLn;
end;

(**
 * @brief Display the full calendar for a year
 *
 * @param year The year to display
 *)
procedure DisplayCalendar(year: Integer);
begin
  DisplayHeader(year);
  DisplayThreeMonths(year, 1, 2, 3);
  DisplayThreeMonths(year, 4, 5, 6);
  DisplayThreeMonths(year, 7, 8, 9);
  DisplayThreeMonths(year, 10, 11, 12);
end;

(**
 * @brief Initialize settings with defaults
 *
 * Initializes all flags to 0 and sets year to the current system year.
 *)
procedure InitializeSettings;
begin
  Settings.flags[0] := 0;
  Settings.flags[1] := 0;
  Settings.flags[2] := 0;
  Settings.flags[3] := 0;
  Settings.year := YearOf(Date);
end;

(**
 * @brief Process command-line arguments
 *
 * Supports setting flag values through `-p <index> <value>`.
 * Exploitation is possible by providing an index beyond 3.
 *)
procedure ProcessArguments;
var
  i: Integer;
begin
  i := 1;
  while i <= ParamCount do
  begin
    if (ParamStr(i) = '-p') and (i + 2 <= ParamCount) then
    begin
      SetFlag(StrToIntDef(ParamStr(i+1), 0), StrToIntDef(ParamStr(i+2), 0));
      i := i + 3;
    end
    else
      i := i + 1;
  end;
end;

(**
 * @brief Main program entry point
 *)
begin
  InitializeSettings;
  ProcessArguments;
  DisplayCalendar(Settings.year);
end.
